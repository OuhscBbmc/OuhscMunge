% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trim.R
\name{trim}
\alias{trim}
\alias{trim_numeric}
\alias{trim_integer}
\alias{trim_date}
\alias{trim_datetime}
\alias{trim_character}
\title{Trim extreme values}
\usage{
trim_numeric(x, bounds=c(-Inf, Inf), replacement=NA_real_)
trim_integer(x, bounds=c(-2147483647L, 2147483647L), replacement=NA_integer_)
trim_date(
  x,
  bounds      = as.Date(c("1940-01-01", "2029-12-31")),
  replacement = as.Date(NA_character_)
)
trim_datetime(
  x,
  bounds      = as.POSIXct(c("1940-01-01 00:00", "2029-12-31 23:59")),
  replacement = as.POSIXct(NA_character_)
)
trim_character(
  x,
  pattern = "^.*$",
  replacement = NA_character_
)
}
\arguments{
\item{x}{The input vector to be trimmed.  Required}

\item{bounds}{A two-element vector that establishes the lower and upper \emph{inclusive} bounds of \code{x}.}

\item{replacement}{A scalar that will replace all instances of \code{x}
that fall outside of \code{bounds} or \code{pattern}.}

\item{pattern}{A perl-style regular expression passed to \code{\link[base:grep]{base::grepl()}}.
Vector elements that match the pattern are returned.
Vector elements that do not match the pattern are replaced with \link{NA_character_}.}
}
\value{
An atomic vector with the same number of elements as \code{x}.
}
\description{
Trim extreme values from an atomic vector, and replace with a specific value (typically \verb{NA_*}).
}
\note{
The data type of \code{x}, \code{bounds}, and \code{replacement} must match the atomic data type of the function.
In other words, \code{trim_numeric()} accepts only parameters of type 'numeric' (otherwise known as
'double-precision floating point').  Likewise, \code{trim_date()} accepts only parameters of type \code{Date}.

The lower bound must be less than or equal the upper bound.

The default bounds for numerics and integers are at the extremes of the data type.
The default bounds for \href{https://stat.ethz.ch/R-manual/R-devel/library/base/html/Dates.html}{dates} are
arbitrary, because the origin is slippery.
}
\examples{
library(OuhscMunge)

trim_numeric(runif(10, -1, 10), bounds=c(4, 8))

trim_integer(c(NA, 1:10), bounds=c(4L, 8L))

trim_date(
  x      = as.Date(c("1902-02-02", "1999-09-09", "2020-02-22", "1930-01-01", "1930-01-02")),
  bounds = as.Date(c("1990-01-01", "2030-01-01"))
)

trim_datetime(
  x      = as.POSIXct(c("1902-02-02", "1999-09-09", "2020-02-22", "1930-01-01", "1930-01-02")),
  bounds = as.POSIXct(c("1990-01-01", "2030-01-01"))
)

zip_codes <- c("12345", "a2345", "54321-6789", "54321-67890")
trim_character(zip_codes, "^\\\\d{5}(-\\\\d{4})?$")
trim_character(zip_codes)                                      # Everything passes.
}
\author{
Will Beasley
}
